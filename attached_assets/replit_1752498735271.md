# MOinMirror - Movie Streaming Web Application

## Overview

MOinMirror is a Flask-based movie streaming web application that allows users to search for movies and stream them directly in their browser. The application scrapes movie streaming links from various sources and provides a Netflix-like interface for browsing and watching content.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture
- **Static HTML/CSS/JS**: Traditional web application using server-side rendering with Flask templates
- **Video Player**: HTML5 video element with HLS.js support for streaming M3U8 files
- **UI Framework**: Custom CSS with Netflix-inspired design
- **JavaScript**: Vanilla JavaScript for dynamic content loading and user interactions

### Backend Architecture
- **Framework**: Flask web framework with Python
- **Template Engine**: Jinja2 for server-side rendering
- **CORS**: Flask-CORS enabled for cross-origin video streaming
- **Logging**: Python logging for debugging and monitoring

### Data Sources
- **Movie Metadata**: OMDb API for movie information (titles, posters, ratings, etc.)
- **Stream Sources**: Multiple scraping targets including:
  - MultiEmbed.mov as primary aggregator
  - MixDrop for direct video streams
  - VidSrc as alternative source
  - Automatic fallback between sources

## Key Components

### API Modules
1. **stream_fetcher.py**: Main streaming logic using Playwright for dynamic content extraction
2. **omdb_fetcher.py**: Movie metadata retrieval from OMDb API
3. **mixdrop_scraper.py**: Specialized scraper for MixDrop video sources
4. **vidsrc_scraper.py**: VidSrc streaming source handler
5. **m3u8_scraper.py**: Generic M3U8 stream extraction using Playwright
6. **auto_stream_scraper.py**: Intelligent source selection with fallback logic

### Web Components
- **app.py**: Main Flask application with routing
- **templates/**: HTML templates for homepage and video player
- **static/**: CSS styling and JavaScript for frontend functionality

### Browser Automation
- **Playwright**: Headless browser automation for JavaScript-heavy streaming sites
- **Persistent Browser**: Global browser instance for performance optimization
- **Network Monitoring**: Real-time capture of M3U8 stream URLs

## Data Flow

1. **User Search**: Frontend sends search query to OMDb API via Flask backend
2. **Movie Selection**: User selects movie, triggering stream fetch request
3. **Stream Extraction**: Multi-source scraping process:
   - Primary: MultiEmbed.mov aggregator
   - Secondary: Direct source scraping (MixDrop, VidSrc)
   - Fallback: Alternative sources with automatic retry logic
4. **Video Playback**: M3U8 stream URL returned to frontend for HLS.js playback

## External Dependencies

### APIs
- **OMDb API**: Movie metadata and search functionality
- **Streaming Sources**: MultiEmbed.mov, MixDrop, VidSrc for video content

### Python Libraries
- **Flask**: Web framework and routing
- **Playwright**: Browser automation for dynamic content
- **BeautifulSoup**: HTML parsing for static content
- **Requests**: HTTP client for API calls
- **Flask-CORS**: Cross-origin resource sharing

### Frontend Libraries
- **HLS.js**: HTTP Live Streaming support in browsers
- **Vanilla JavaScript**: No frontend frameworks used

## Deployment Strategy

### Environment Configuration
- **Environment Variables**: Session secrets and API keys
- **Development Mode**: Local development with debug enabled
- **Production Considerations**: Headless browser optimization for server deployment

### Browser Requirements
- **Chromium**: Required for Playwright browser automation
- **System Dependencies**: Proper handling of sandboxing and GPU acceleration
- **Resource Management**: Single-process mode for memory efficiency

### Performance Optimizations
- **Persistent Browser**: Global browser instance to avoid startup overhead
- **Resource Blocking**: Filtering unnecessary assets (images, CSS) during scraping
- **Timeout Management**: Configurable timeouts for stream extraction
- **Fallback Data**: Hardcoded movie data for API failures

The application prioritizes reliability through multiple fallback mechanisms and performance through persistent browser instances and efficient resource management.